---
name: create-new-mcp
description: Guide for integrating new MCP servers into the Docker stack
---

# MCP Server Integration Guide

> **Note:** This guide covers MCP-specific integration steps. For general Docker service patterns (extension files, environment variables, documentation, naming, testing), see `@.cursor/rules/create-new-service.mdc`.

## Integration Patterns Overview

Three integration patterns exist:

1. **Self-written MCP server** (TypeScript/Node.js): Full NPM package in `packages/mcp-{name}/`, custom Dockerfile, GitHub Actions workflow. Examples: `mcp-calculator`, `mcp-image-gen`.
2. **External published Docker image**: Use existing image directly, no package/Dockerfile needed. May require `command` override or custom healthcheck. Examples: `mcp-firecrawl`, `mcp-weather`.
3. **External submodule with modifications**: Git submodule in `dev/{name}-mcp/`, build from submodule Dockerfile. Examples: `mcp-openstreetmap`.

**Common steps for all patterns:**
- Docker Compose base file (`docker-compose.mcp-{name}.yml`)
- Extension files (`docker-compose.local.yml`, `docker-compose.local-source.yml`, `docker-compose.prod.yml`)
- Environment variables (`env.local.example`, `env.prod.example`, `env.dev.example`)
- LibreChat configuration (`librechat.yaml`: `mcpSettings.allowedDomains`, `mcpServers`)
- Icon asset (`packages/librechat-init/assets/mcp-{name}-icon.svg`)

## Pattern 1: Self-Written MCP Server

### 1.1 NPM Package Structure
Create `packages/mcp-{name}/`:
- `package.json`: `@ai-chat-interface/mcp-{name}`, `type: "module"`, dependencies: `@modelcontextprotocol/sdk`, `zod`, `express`, `pino`, `dotenv`, `"start": "./src/server.ts"` script
- **After dependencies**: Run `npx npm-check-updates -u`, then `npm install`
- **Executable**: `chmod +x ./src/server.ts` (required for `"start": "./src/server.ts"`)
- **Local dev scripts**: Add `dotenv-cli` to `devDependencies`, scripts: `"start:local": "dotenv -e ../../.env.local -- ./src/server.ts"`, `"dev:local": "dotenv -e ../../.env.local -- node --watch ..."`, `"test:integration:local": "dotenv -e ../../.env.local -- ./test/integration.ts"`, `"test:http:local": "dotenv -e ../../.env.local -- ./test/http-test.ts"`
- `tsconfig.json`: ES2022, NodeNext, strict mode, noEmit (run TS directly)
- `src/server.ts`: Express server with `/mcp` endpoint, session management via `mcp-session-id` header, health endpoint at `/health` (executable: `chmod +x`)
- `src/tools/`: Tool implementations with Zod schemas
- `src/utils/logger.ts`: Pino logger with `LOG_LEVEL` env var
- `src/utils/errors.ts`: Custom error classes
- `Dockerfile`: Node 24-alpine, non-root user, run TS with `--experimental-strip-types`, healthcheck
- `.dockerignore`, `.gitignore`: Standard Node.js patterns

### 1.2 Docker Compose Base File
Create `docker-compose.mcp-{name}.yml`:
- Service: `mcp-{name}`
- **Fallback image**: Base image (e.g., `node:24-alpine`) - used if build fails or for testing without build
- Networks: `app-net` only (internal service, **no Traefik**)
- Environment: `PORT`, `LOG_LEVEL`, optional `API_KEYS`
- Expose port (no publish) - internal access only
- Healthcheck: HTTP GET `/health`, interval 30s, timeout 10s, retries 3, start_period 40s
- Resource limits: 0.5 CPU, 256M memory
- **Note**: Extension files with `build` sections MUST override with unique image name to prevent Docker layering issues

### 1.3 GitHub Actions Workflow
Create `.github/workflows/build-mcp-{name}.yml` (see `@.cursor/rules/create-new-service.mdc` section 5):
- Trigger: Push to `packages/mcp-{name}/**` or workflow file changes
- Build context: `./packages/mcp-{name}`
- Image: `ghcr.io/faktenforum/mcp-{name}`
- Tags: `latest` (default branch), `dev` (feature branches), branch name
- Platform: `linux/amd64`
- Cache: GitHub Actions cache

## Pattern 2: External Published Docker Image

### 2.1 Docker Compose Base File
Create `docker-compose.mcp-{name}.yml`:
- Service: `mcp-{name}`, image: External image (e.g., `ghcr.io/org/mcp-server:latest`, `dockerhub-user/image:tag`)
- Networks: `app-net` only (internal service, **no Traefik**)
- Environment: Map required env vars (e.g., `PORT`, `API_KEY`, `HTTP_STREAMABLE_SERVER: "true"`)
- **Command override** (if needed): Override for streamable-http mode (Python example: `["sh", "-c", "uv run python -m module --mode streamable-http --host 0.0.0.0 --port $${MCP_NAME_PORT:-3000}"]`)
- Expose port (no publish) - internal access only
- **Healthcheck** (interval 30s, timeout 10s, retries 3, start_period 40s):
  - **HTTP endpoint** (preferred): `test: ["CMD", "node", "-e", "require('http').get('http://localhost:PORT/health', (r) => { process.exit(r.statusCode === 200 ? 0 : 1) }).on('error', () => process.exit(1))"]`
  - **Socket check** (fallback): `test: ["CMD-SHELL", "python -c 'import socket; s=socket.socket(); s.settimeout(1); result=s.connect_ex((\"localhost\", PORT)); s.close(); exit(0 if result == 0 else 1)'"]`
- Resource limits: 0.5 CPU, 256M memory
- Logging: json-file driver, max-size 10m, max-file 3, compress true

### 2.2 Extension Files
In `docker-compose.local.yml`, `docker-compose.local-source.yml`, `docker-compose.prod.yml`:
- Extend base service: `extends: { file: docker-compose.mcp-{name}.yml, service: mcp-{name} }`
- Add `env_file: .env.local` (local files only)
- Add `container_name: ${STACK_NAME:-prod}-mcp-{name}` (prod only)
- **No build section** - uses external image directly
- **Note**: If overriding with build, always set unique `image:` name different from base image

### 2.3 No Package/Workflow Needed
- No NPM package structure required
- No GitHub Actions workflow (image maintained externally)
- No Dockerfile (uses external image)

## Pattern 3: External Submodule with Modifications

### 3.1 Git Submodule Setup
Add submodule to `dev/{name}-mcp/`:
- Add to `.gitmodules`: `[submodule "dev/{name}-mcp"]`, `path = dev/{name}-mcp`, `url = git@github.com:org/{name}-mcp.git`
- Initialize: `git submodule update --init --recursive dev/{name}-mcp`
- Update `dev/README.md` with submodule reference

### 3.2 Docker Compose Base File
Create `docker-compose.mcp-{name}.yml`:
- Service: `mcp-{name}`, **fallback image**: Base image (e.g., `python:3.13-slim`) - used if build fails or for testing without build
- Networks: `app-net` only (internal service, **no Traefik**)
- Environment: `PORT`, other required vars
- Expose port (no publish) - internal access only
- **Healthcheck** (interval 30s, timeout 10s, retries 3, start_period 40s): Socket check (if no HTTP endpoint) or HTTP check (if available)
- Resource limits: 0.5 CPU, 256M memory
- Logging: json-file driver, max-size 10m, max-file 3, compress true

### 3.3 Extension Files with Build
In `docker-compose.local-source.yml` and `docker-compose.prod.yml`:
- Extend base service: `extends: { file: docker-compose.mcp-{name}.yml, service: mcp-{name} }`
- **Build section**: `build: { context: ./dev/{name}-mcp, dockerfile: Dockerfile }`
- **CRITICAL**: Always set unique `image:` name (e.g., `ghcr.io/faktenforum/mcp-{name}:latest` for main branch, `:dev` for feature branches) to prevent Docker layering built image on base image
- Add `env_file: .env.local` (local-source only)
- Add `container_name: ${STACK_NAME:-prod}-mcp-{name}` (prod only)
- Add `pull_policy: build` (prod only)
- Comment: `# Build from submodule Dockerfile (like rag_api)`

### 3.4 No GitHub Actions Workflow
- No workflow needed (submodule maintained externally, or build handled by Portainer/Git-based deployment)

## Common Steps (All Patterns)

### Extension Files & Environment Variables
Follow `@.cursor/rules/create-new-service.mdc` sections 2-3, MCP-specific: **No Traefik labels** (internal only, Docker network access). Extension files: `docker-compose.local.yml`, `docker-compose.local-source.yml`, `docker-compose.prod.yml`. Environment pattern: `MCP_{NAME}_PORT=3000`, `MCP_{NAME}_LOG_LEVEL=info`, optional `MCP_{NAME}_API_KEYS` (comma-separated). Add to all three: `env.local.example`, `env.prod.example`, `env.dev.example`.

### LibreChat Configuration
Update `packages/librechat-init/config/librechat.yaml`:

**Add to `mcpSettings.allowedDomains`:** `- 'mcp-{name}'  # MCP {Name} service (Docker network)`

**Add to `mcpServers` (include title, description, iconPath):**
```yaml
mcpServers:
  {name}:
    type: streamable-http
    url: http://mcp-{name}:{PORT}/mcp
    title: {Display Name}  # Human-readable title shown in LibreChat UI
    description: {Brief, user-friendly description}  # Keep short (truncated in UI), avoid technical terms
    iconPath: /images/mcp-{name}-icon.svg  # Path relative to LibreChat's public images directory
    initTimeout: 120000
    chatMenu: true  # Show in chat dropdown (or false for agents only)
    startup: true   # Auto-start with LibreChat
    serverInstructions: true  # Include server instructions
```

**Description guidelines:** Keep short (UI truncates), user-friendly language (end users, not developers), avoid technical terms ("MCP Server", "API", "endpoint"), focus on what tool does. Example: "Mathematische Berechnungen und Rechenoperationen" not "MCP Server f√ºr mathematische Berechnungen".

### MCP Server UI Assets (Icon)
**Icon setup:**
1. Create `packages/librechat-init/assets/mcp-{name}-icon.svg` (24x24 SVG, Lucide-compatible, naming: `mcp-{name}-icon.svg` must match pattern)
2. No code changes: `librechat-init/src/init.ts` automatically copies all `mcp-*-icon.svg` files from `/app/assets/` to `/images/` during initialization

**Why:** Icons must be browser-accessible (LibreChat web UI), but MCP servers are internal-only. `librechat-init` copies to `/images/` volume served by LibreChat's static route. No Traefik exposure needed. Works in local dev and Portainer/production.

**After icon changes:** Rebuild `librechat-init` and restart stack:
- Local: `npm run build:local` (or `npm run build:local librechat-init`)
- Production/Portainer: Redeploy from Git (auto-rebuild) or manual rebuild

### Server Implementation Pattern (Self-Written Only)
```typescript
// Session management
const transports = new Map<string, StreamableHTTPServerTransport>();

function getSessionId(headers: Request['headers']): string | undefined {
  const header = headers['mcp-session-id'] || headers['Mcp-Session-Id'];
  return typeof header === 'string' ? header : undefined;
}

// Express routes
app.post('/mcp', async (req, res) => {
  const sessionId = getSessionId(req.headers) || randomUUID();
  let transport = transports.get(sessionId);
  if (!transport) {
    transport = new StreamableHTTPServerTransport('/mcp', res);
    transports.set(sessionId, transport);
    await server.connect(transport);
  }
  // Handle request...
});

app.get('/health', (req, res) => {
  res.json({ status: 'ok', service: 'mcp-{name}' });
});
```

### Documentation & Naming
Follow `@.cursor/rules/create-new-service.mdc` sections 8 and 10, plus MCP-specific:
- Package name (self-written only): `@ai-chat-interface/mcp-{name}` (kebab-case)
- LibreChat server key: `{name}` (camelCase or kebab-case)
- Environment prefix: `MCP_{NAME}` (UPPER_SNAKE_CASE)
- Create `packages/mcp-{name}/README.md` (self-written only): Tool descriptions, development setup

### Testing
**Self-written servers:** Follow `@.cursor/rules/create-new-service.mdc` section 11, plus MCP-specific:
- Local dev: `npm run dev:local` (loads `.env.local` from root) or `npm run dev` (container env)
- Integration test: `npm run test:integration:local` (loads `.env.local`) or `npm run test:integration` (container env)
- HTTP test: `npm run test:http:local` (loads `.env.local`) or `npm run test:http` (container env)
- **Test path fix**: In `test/integration.ts`, use `join(__dirname, '../../..')` for `WORKSPACE_ROOT` (3 levels up from test/ to workspace root)

**All patterns:** LibreChat testing - check agent configuration, test tools in chat, verify MCP server appears in UI.

## Key Differences from Regular Services
- **No Traefik**: Internal only, accessed via Docker network (`app-net` only, no `traefik-net`)
- **Port**: Expose only, never publish
- **TypeScript direct execution** (self-written only): No build step, use `--experimental-strip-types`
- **Session management** (self-written only): Required for streamable-http transport
- **Health endpoint**: Required for Docker healthchecks (HTTP endpoint preferred, socket check fallback)
- **LibreChat config**: Must add to `mcpSettings.allowedDomains` and `mcpServers` with `title`, `description`, `iconPath`
- **Icon serving**: Icons served via LibreChat's `/images/` route (copied by `librechat-init`), not directly by MCP server
- **UI assets**: Title, description, and icon configured in `librechat.yaml`, not in MCP server code
